#!/usr/bin/env bash

################################################################################
# Template for quickly getting started when facing the task of writing smaller
# bash scripts. To suggest a good structure, and serve as a reminder for some of
# the details and conventions of bash.
#
# jseb@github 2011-10-29
#
################################################################################

# -- useful bash modes ---------------------------------------------------------
# set -o xtrace
# After  expanding  each simple command, for command, case command, select
# command, or arithmetic for command, display the expanded value of PS4,
# followed by the command and its expanded arguments or associated word list.
# (in plain english: print everything that gets executed, great for debugging)

set -o errexit
# Exit immediately if a simple command (see SHELL GRAMMAR) exits with a
# non-zero status.

set -o nounset
# Treat unset variables as an error when performing parameter expansion.  If
# expansion is attempted on an unset variable, the shell prints an error
# message, and, if not interactive, exits with a non-zero status.

# -- global variables ----------------------------------------------------------
tmpdir="/tmp/$RANDOM-$RANDOM-$RANDOM"
feed_path="$tmpdir/feed.xml"
tmp_music_file="$tmpdir/musicfile"
number_of_episodes=20
randomize=false
show_help=false

# -- functions -----------------------------------------------------------------
function print_start() {
    bold="\033[1m"
    normal="\033[0m"
    abgt="Group Therapy with Above & Beyond"
    link="aboveandbeyond.nu"
    echo -e "$bold$abgt"
    line=$(sed 's/./-/g' <<< $abgt)
    index=$(((${#abgt}-${#link})/2))
    echo -e $normal${line:0:index-1} $link ${line:0:index-1}"\n"
}

function download_feed() {
    $(curl -f -s -o "$feed_path" "http://static.aboveandbeyond.nu/grouptherapy/podcast.xml" || true)
}

function play() {
    if [[ $randomize = true ]]
    then
      echo -e "Playing $number_of_episodes latest episodes randomly."
    else
      echo -e "Playing $number_of_episodes latest episodes."
    fi
    for url in $1
    do
        if [[ $randomize = true ]]
        then
          random_episode=$(echo $RANDOM % $number_of_episodes + 1 | bc)
          echo -e "Random episode $random_episode"
          url=$(echo -e $1 | awk -v rand=$random_episode -F ' ' '{print $rand}')
        fi
        echo "Downloading episode: $url"
        curl --location -# $url > $tmp_music_file
        echo "Playing episode"
        afplay -q 1 $tmp_music_file
    done
}

function play_latest_episodes() {
    episode_urls=$(grep enclosure $1| grep -o "http://[a-zA-Z0-9.\/_-]*.m[p4][3a]" | head -n $number_of_episodes || true)
    episode_urls=$(sed 's/\\n/ /g' <<< $episode_urls)
    if [ -n "$episode_urls" ]
    then
        play "$episode_urls"
    else
        echo "Error: No episodes found."
    fi
}

function usage() {
    echo "usage: abgt [-r]
         -r is optional and if this option is given, the episodes are randommized."
}

function cleanup() {
    # remove temporary work dir
    if [[ -d "$tmpdir" ]]
    then
        # cd into /tmp first, just in case $tmpdir has been set to any path
        # outside of /tmp. Also, chaining the commands so that if cd /tmp
        # fails, rm -rf will not get executed
        cd /tmp && rm -rf $(basename "$tmpdir")
    fi
}

# -- initialize ----------------------------------------------------------------
# -- error handling
# this trap is run on any exit, signalled or not
trap cleanup EXIT

hash afplay 2>&- || ( echo >&2 "ERROR: afplay not installed, exiting.." && exit 1 )
hash curl 2>&- || ( echo >&2 "ERROR: curl not installed, exiting.." && exit 1 )

# -- temporary work dir
mkdir "$tmpdir" && cd "$tmpdir"

# -- command line options
# getopts is a POSIX standard way of handling command line arguments. One
# downside of using it is that it can't handle long options.
while getopts "r" opt
do
    case $opt in
        r) randomize=true ;;
        ?) show_help=true ;;
    esac
done

if [[ $show_help = true ]]
then
    usage
    exit 1
fi

# -- main ----------------------------------------------------------------------
print_start
download_feed
if [ -e "$feed_path" ]  && [ -s "$feed_path" ]
then
    play_latest_episodes "$feed_path"
else
    echo "ERROR: Failed to get feed."
fi
